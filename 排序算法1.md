1.如何衡量一个排序算法的优劣；

1.1算法的执行效率

a.最好、最快、平均时间复杂度

b.T(n)=O(2n^2+3n+4)=O(f(n))=O(n^2)

需要考虑时间复杂度的系数（当数据比较少），**系数、低阶、常数（冒泡、插入）**，由于n的大小不是足够大；

c.比较或者交换的次数。

**1.2算法的内存消耗：通过空间复杂度衡量**

原地排序：特指空间复杂度为O（1）的排序算法（问法  这个时间复杂度是不是原地排序）



**1.3算法的稳定性（重要）**

稳定性： 若待排序的集合中存在值相等的元素，经过排序之后，相等元素之间原有的顺序是否改变

 若未改变，则称此排序为稳定性排序。

例子：

订单：金额，下单时间

300  17：00：00

301  14：00：00

300  18：00:   00

需求：如何按照金额排序后的数据，时间也是有序的？相同金额的订单按照时间顺序排序.

解决：先按照时间顺序排序依次，再按照金额（稳定）排序一次

**快排**  **归并**



2.排序分类

内部排序：排序过程无序借助外部存储器，所有排序操作均在内存中完成。默认说的排序都是内部排序；



外部排序：若参与排序的元素过多，数据量过大，内存放不下，需要借助外部存储器进行排序（桶排序）



无论是内部排序还是外部排序，最终数据的排序一定在内存中。



内部排序按照排序思路分为以下四类：

2.1插入排序

1.直接插入排序：

时间复杂度：最好 O（n）

​		       最坏 O（n^2）

空间复杂度：O（1）

稳定性：插入排序是一个稳定性算法；

2.希尔排序：



2.2选择排序：

选择排序

堆排序：（二叉树以后讲）



2.3交换排序：

​	冒泡排序：

​	时间复杂度O（n^2）

​	空间复杂度O（1）

​	稳定排序

快速排序：



2.4归并排序



3. O（n^2）时间复杂度排序

冒泡、插入、选择

**3.1 冒泡排序：**

冒泡排序只会操作相邻两个元素。每次对相邻两个元素做大小比较，看是否满足大小关系。

一次冒泡至少会让一个元素在最终的位置上（冒泡）



排序前：4、5、6、1、2、3    按照升序排序

第一次排序：4、5、1、2、3、6   截止位置array[n-1]

第二次排序：4、1、2、3、5、6  截止位置 array[n-2]

第三次排序：1、2、3、4、5、6 截止位置array[n-3]

···········

​							截止位置array[0];



优化：设置标志位，若在某次循环结束后发现并没有元素交换，认为数据集已经有序，停止循环。

**算法执行效率：**

最好情况：

数据集本身就是一个有序集合，O（n^2）

最坏情况：

数据集完全逆序O(n)

平均情况:

O（n^2）

**算法的内存消耗**：O（1），无需开辟新的空间，仅仅是原有的数据集作交换。

冒泡排序是一个原地排序算法。



**算法的稳定：**由于是进行相邻元素发生大小元素变化才会交换次序，所以当两个元素大小相等时，并不会改变其相对顺序。





```java
public static void bubbleSort(int[] array){
        int n=array.length;
        if(n<=1){
            return ;
        }else{
            for(int i=0;i<n-1;i++){
                int flag=0;
                for(int j=0;j<n-i-1;j++){
                    if(array[j]>array[j+1]){
                        int temp=array[j];
                        array[j]=array[j+1];
                        array[j+1]=temp;
                        flag=1;
                    }
                }
              if(flag==0){
                    break;
              }
            }
        }
    }
```



4.直接插入排序：基于有序数组元素内容的插入得来；

核心思想:将待排序的数据分为两个区间，已排序区间和待排序区间。

算法刚开始时，已排序空间有一个，在待排序空间中选择第一个元素与已排序空间最后一个元素比较，

若比已排序的最大元素大，直接放入已排序空间最后一个位置，否则需要找到合适位置后进行插入。

```java
public static void insertSort(int[] array){
        int n=array.length;
        if(n<=1){
            return ;
        }else{
            //待排序的集合
                for(int i=1;i<n;i++){//将第一个元素作为有序空间，
                    int temp=array[i];
                    int j=i-1;
                    //找要插入的位置
                    for(;j>=0;j--){
                        if(temp<array[j]){
                            //如果待插入元素比有序空间的最后一个元素小，将有序空间的最后一个元素向后移							一位	
                            array[j+1]=array[j];
                        }else{
                            //如果比他大或者等于他，不变跳出循环
                            break;
                        }
                    }
                    array[j+1]=temp;  //为什么要j+1 因为每次比较都是与前面一个比较大小，如果那么要查入									的位置就是j后面的那个位置
            }
        }
```



时间复杂度：最好 O（n）

​		       最坏 O（n^2）

空间复杂度：O（1）

稳定性：插入排序是一个稳定性算法；



-------------------------------



**折半插入排序**（直接插入的优化）

优化：寻找插入位置，从中间值开始比较

二分查找的思想：在一个有序数据集上查找一个元素，先与最中间位置的元素比较，如果比这个元素小，则在中间位置的左边，否则在右边，一直改变左右边界值，直到左边界值直到找到元素为止；

折半插入排序的思想：序列分为有序区间和无序区间，既然是有序区间，就一定可以通过折半查找的思想，找到待排序数组的第一个元素，在有序区间的位置；





---------------------------------------------------------------------------------------------------------------------------------------



**希尔排序：**

优化：原先找到插入位置后元素是一个一个搬移，损耗较大。

能否在搬移元素时多走几步，即一次多搬几个元素。



原先：    一次走一步

​		一次走多步

1.将数组按照要走的步数分为若干组  step=n/2，,

2.每组进行插入排序

3.重复1,2 知道步数缩小至1，





-----------------------------------------------------------------------------------------------------------------------------------------------------------



**选择排序**：将一组数据分为已排序空间和未排序空间，将未排序空间的最小值放到已排序空间的末尾。时间复杂度

时间复杂度：O（n^2）

空间复杂度：原地排序：

**稳定性：不稳定排序  5 8 5 2 9**

选择还是插入？                                                                                        

在相同数据集下，推荐使用插入排序，由于选择排序的不稳定性，





在随机的数据集下，？  时间：  冒泡>插排>选择>折半插排>希尔

**在近乎有序的数据集下，直接插排，选择排序，希尔，折半插排的性能问题？**

直接插排效率比较快



------------------------------------------------

**归并排序**：分治思想：

###重要

**如何在O（n）,这个时间复杂度内寻找一个无数组的第K大元素?**   



**什么是分治思想，讲一个大的问题分为若干个足够小的问题，当所有小问题解决后，将结果合并起来，就是整个问题的求解。**



**分治思想的所有代码都可以用递归实现完美解决（代码简单）。**

1.分割，利用递归将数组分为若干个小数组当 小数组的左边界值大于等于右边界值的时候，停止递归

2.合并，开辟一个新数组将，两个数组的较小值放到新前面，较大值放到新数组的后面；

-----------------------------------------------------------------------------------------------------------------------------------------------------------







