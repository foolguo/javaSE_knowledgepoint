翻转链表 :

方法一： 时间复杂度O(N)，空间复杂度O(N)

```java
public ListNode reverseList(ListNode head) {
            if(head==null){
            return null;
        }
        ListNode dummyHead=new ListNode(-1);
       for(ListNode temp=head;temp!=null;temp=temp.next){
            ListNode curr=new ListNode(temp.val);
            curr.next=dummyHead.next;
            dummyHead.next=curr;
        }
        return dummyHead.next;
    }
    
```



遍历，头插插入行的链表：

优化空间复杂度（O（1））



dummy-1-2-3-4-5

​		f  s

dummy-2-1-3-4-5

​	           f  s   	

dummy-3-2-1-4-5

​                      f  s

dummy-4-3-2-1-5

​			  f  s

dummy-5-4-3-2-1



```java
public ListNode reverseList(ListNode head) {
        ListNode dummyHead=new ListNode(-1);
        dummyHead.next=head;
        if(head==null||head.next==null){
            return head;
        }else{
            ListNode first=dummyHead.next;
            ListNode second=first.next;
            while(second!=null){
                first.next= second.next;
                second.next=dummyHead.next;
                dummyHead.next=second;
                second=first.next;
            }
        }
        return dummyHead.next;
    }
```



中间节点

方法一：我的方法



方法二：（快慢指针）两个节点，第一个节点一次走一步，第二个节点，一次走两步，（快的走到了终点，慢的走到中间节点）

快慢指正：



列子： 1234

f=1 f=3 f=null

l=1   l=2  l=3

12345

f=1 f=3 f=5 

f=1 f=3 f=3;



倒数节点：

让第一个节点先走k(倒数步数)







回文链表

1.找到中间位置

2.将第二个链表转置

3.将第一个链表与第二个链表一次向后遍历，比较

1-2-3-2-1

1-2-3-1-2；

