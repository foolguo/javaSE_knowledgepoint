翻转链表 :

方法一： 时间复杂度O(N)，空间复杂度O(N)

```java
public ListNode reverseList(ListNode head) {
            if(head==null){
            return null;
        }
        ListNode dummyHead=new ListNode(-1);
       for(ListNode temp=head;temp!=null;temp=temp.next){
            ListNode curr=new ListNode(temp.val);
            curr.next=dummyHead.next;
            dummyHead.next=curr;
        }
        return dummyHead.next;
    }
    
```



遍历，头插插入行的链表：

优化空间复杂度（O（1））



dummy-1-2-3-4-5

​		f  s

dummy-2-1-3-4-5

​	           f  s   	

dummy-3-2-1-4-5

​                      f  s

dummy-4-3-2-1-5

​			  f  s

dummy-5-4-3-2-1



```java
public ListNode reverseList(ListNode head) {
        ListNode dummyHead=new ListNode(-1);
        dummyHead.next=head;
        if(head==null||head.next==null){
            return head;
        }else{
            ListNode first=dummyHead.next;
            ListNode second=first.next;
            while(second!=null){
                first.next= second.next;
                second.next=dummyHead.next;
                dummyHead.next=second;
                second=first.next;
            }
        }
        return dummyHead.next;
    }
```



中间节点

方法一：我的方法

```java
  public ListNode middleNode(ListNode head) {
        //1.寻找中间结点
        int size=0;
        for(ListNode temp=head;temp!=null;temp=temp.next){
            size++;
        }
        size=size/2+1;
        //2.取出：
        ListNode temp=head;
        for(int i=0;i<size-1;i++){
            temp=temp.next;
        }
        return temp;
    }
```



方法二：（快慢指针）两个节点，第一个节点一次走一步，第二个节点，一次走两步，（快的走到了终点，慢的走到中间节点）：

快慢指针

列子： 1234

f=1 f=3 f=null

l=1   l=2  l=3

12345

f=1 f=3 f=5 

f=1 f=3 f=3;

```java
 public ListNode middleNode(ListNode head) {
        if(head==null){
            return null;
        }
        ListNode dummyHead=new ListNode(-1);
        dummyHead.next=head;
        ListNode first=head;
        ListNode second=head;
        while (first.next!= null) {
                if (first.next.next != null) {
                    first = first.next.next;
                    second=second.next;
                } else {
                        first=first.next;
                    second=second.next;

                }
            }
        return second;
    }
```



倒数节点：

让第一个节点先走k(倒数步数)

第二个结点从头结点开始走；

```java
public ListNode FindKthToTail(ListNode head,int k) {
         //1.看看一共有多少个结点，
        //2.看这个倒数的结点在整数的第几个
        
        if(head==null){
            return null;
        }
        
        ListNode first=head;
        ListNode second=head;
       for(int i=0;i<k;i++){
           if(first!=null){
               first=first.next;
           }else{
               return null;
           }
       }
        while(first!=null){
            first=first.next;
            second=second.next;
        }
        return second;
```

方法二： 1.看看一共有多少个结点，
        	2.看这个倒数的结点在整数的第几个

​		3.总个数-倒数步数就是  倒数节点在的位置

```java
  public ListNode FindKthToTail(ListNode head,int k) {
        
        int size=0;
        for(ListNode temp=head;temp!=null;temp=temp.next){
            size++;
        }
        /* size=6
        k:1->6
        k:2->5
        k:3->4
        k:4->3
        k:5->2
        k:6->1*/
        ListNode temp=head;
        if(k<0||k>size){
            return null;
        }
        for(int i=0;i<size-k;i++){//走size-k步得到结点
            temp=temp.next;
        }
        return temp;
    }
```







回文链表

1.找到中间位置

2.将第二个链表转置

3.将第一个链表与第二个链表一次向后遍历，比较

1-2-3-2-1

1-2-3-1-2；

```java
if(A==null){
            return false;
        }
        //找到中间节点
        ListNode first=A;
        ListNode mid=A;//中间结点,作为下一个链表的前驱结点
		//找到中间节点，奇数为中间的，偶数为中间两个的前一个
        while(first.next!=null){
            if(first.next.next!=null){//奇数情况（在最后一步时一定会进入此分支）
                first=first.next.next;
                mid=mid.next;
            }else{//偶数情况，（最后一步一定会进此分支）
                first=first.next;//走这一步是为了结束循环
            }
        }
        ListNode prev=mid;
        ListNode first_1=mid.next;
        if(first_1==null){//如果中间节点的下一个结点为空，那么链表中只有一个结点
            return true;
        }
        ListNode second=first_1.next;
        if(second==null){//如果中间节点的下两个节点为空，中间节点的两边一定只有一个结点  1-2-1结构
            return A.val==first_1.val;
        }
        while(second!=null){//将中间节点后面的结点翻转
            first_1.next=second.next;
            second.next=prev.next;
            prev.next=second;
            second=first_1.next;
            
        }
        ListNode temp=A;
        mid=mid.next;
        while(mid!=null){//比较
            if(mid.val!=temp.val){
                break;
            }
            mid=mid.next;
            temp=temp.next;
        }
        if(mid==null){//如果是回文链表。那么一定走到了链表尾部
            return true;
        }
            return false;
}
```



方法二：将每一个结点的值放到数组里，然后进行比较

```java
public class PalindromeList {
    public boolean chkPalindrome(ListNode A) {
        // write code here
           int size=0;
        for(ListNode temp=A;temp!=null;temp=temp.next){
            size++;
        }
        int[] datas=new int[size];
        int i=0;
        for(ListNode temp=A;temp!=null;temp=temp.next){
            datas[i++]=temp.val;
        }
        i=i-1;
        int j=0;
        for (j=0,i=size-1;j<i;j++,i--){
            if(datas[i]!=datas[j]){
                break;
            }
        }
        if(i<=j){
            return true;
        }
        return false;
    }
```

