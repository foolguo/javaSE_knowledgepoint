java命名模式，

小驼峰，用于方法名 首单词小写第二个单词开始首字母大写

大驼峰，用于类名 单词字母全部大写

常量名：全大写不同单词中间用_隔开

java的跨平台性主要依赖JVM JVM将 *.java文件编辑成与平台无关的 *.class文件，然后在另一平台上，

*.class文件可以直接运行



 java的数据类型



基本数据类型 ：8 种  byte short int long (0)  float double(0.0)  boolean(false ) char(\uoooo) ;

引用数据类型 ：数组,类，接口 ，



整形常量的类型为int   浮点型的默认类型为double 

java中所有的运算都是从右至左的，

小转大自动 （byte范围内自动 ） 大转小强转

java关键字

class  interface ( 分别是类和接口)

extends(继承   单继承) implements(实现   多实现)

private default protected public (访问权限控制符 私有 包访问权限 继承访问权限 共有)

this (本类属性 ，本类方法，当前对象)   super(父类属性，方法)（在构造方法中时不能一起使用，因为它们都要出现在构造方法的第一行）

abstract   (修饰抽象类和抽象方法  只能用在抽象类和接口中) final(终结器  修饰类 该类不能被继承  修饰方法 该方法不能被覆写 ，修饰变量 变脸在进行+-*/时不会进行类型转换， 必须要赋初值)

new： 表示对象实例化，出现new就出现新的堆空间



面向对象程序设计，

封装性：将客观事物封装成抽象的类，并且将自己的数据和方法让可信任的对象操作，对不可信任的对象隐藏，外部对内部的不可见性；

继承性：可以使用现有类的所有功能，并且再不用重新编写原来类的情况下对现有功能进行扩充，

多态性：类的实例的相同方法在不同情形下的不同表现形式，



解释面向过程和面向对象语言的区别：

面向过程：简单描述是吃狗屎，不关注操作的具体对象，只关注吃狗屎这个动作

面向对象：狗吃屎，关注的点是谁干了这件事情，至于吃的过程不关注；

面向过程的三大特性：

封装性：内部操作对外部不可见，注重保护性；

继承性：指一种特殊的能力，再不用编写任何代码的情况下就可以使用现有类的所有功能并且在不用重新编写的情况下对现有功能进行扩充；代码复用，

多态性：同一个属性在不同情况下的不同表现形式，   （代码得到良好的设计）

封装：1.private进行封装；2，内部类进行封装；3.final进行封装

继承：extends继承  接口继承 ，内部类继承

多态：1.方法对态；重写，覆写   2.对象多态；向上、向下转型

OOA，面向对象分析

OOD，面向对象设计

OOP，面向对象编程

先产生类，再产生对象，类是产生对象的宏图

类{属性和方法}

1.构造方法

2.方法的重载，方法名称完全一致，参数列表不同，与返回值无关；

3，this关键字，this()放在构造方法的第一行， this.方法名，this.属性名  ， this表示当前对象

4.static(静态属性，静态方法，静态代码块，静态内部类)

5.继承

6.关键字super

7.代码块

8.方法的覆写

9.内部类:

```
1.什么是内部类：内部类就是在类中嵌套其他类的的结构
2.为什么存在内部类：
        1.内部类可以直接访问外部类的成员变量
        2.内部类对于包中其他类完全隐藏
        3.内部类弥补了Java中单继承的缺点；
3.内部类和外部类的关系：
        1.对于非静态内部类而言，内部类的创建是依赖外部类的
        2.和外部类不是is-a 关系
        3.直接访问外部类
4.分类
成员内部类：不能拥有静态属性，但是可以访问外部类的静态属性
静态内部类：可以拥有普通域，但是不能访问外部类的普通属性
局部内部类/方法内部类：1.作用域，只在方法内有效果；2.拥有局部内部类的方法形参必须要用final修饰 Jdk8后省略 3.不能拥有任何的访问权限
匿名内部类：
```

10.final

1.修饰类，该类为最终类，不能被继承

2.修饰方法，该方法不能被覆写

3.修饰变量，必须赋初值；

4.修饰普通变量，普通变量的类型不会改变，并且不能改变；final修饰成员变量的时候，成员变量可以在构造方法内赋初值；



多态性：对象多态性

1.向上转型：自动的，目的参数统一（代理模式，代理类中构造方法的形参）；

2.向下转型：手动的， 必须要先要发生向上转型才可以发生向下转型；

（在进行 equals方法覆写时可以做）；

instanceof：对象引用 是指向目标类

在进行向下转型时，父类要调用子类的扩充功能时

if（对象引  instancof 目标类）





抽象类和接口为什么存在？要让子类强制覆写父类的方法：

抽象类；

1.抽象类就是比普通类多了一下抽象方法而已，抽象类是普通类的超集，

2.所有抽象类必须被继承，如子类是非抽象类则所有抽象方法必须被覆写

3.进行对象多态性进行实例化；

4.private和abstract private 与final不能一起使用

注意事项：1.抽象类不能实例化对象，虽然有些抽象类没有抽象方法但是依旧无法实例化对象 

2.在进行子类实例化之前依旧要先实例化父类构造方法；

接口 ：在JDK8之前，由全局常量和抽象方法构成

1.关键字，用interface定义接口 ，子类使用implements实现接口

2.接口可以多实现：

3.接口只可以用public权限，就算没有写也是public权限，

4.抽象类可以实现接口，接口不能实现抽象类：

5.接口可以继承多个接口



设计模式：（以前人们在编程是总结的好的模式，用来解决一些特定的场景）

OCP原则：对修改关闭，对扩展开放；

模板设计模式，（核心：模板方法，第三方）

1.适合于加盟点=电

2.例子 冲泡咖啡因饮料

工厂模式：将类的实例化交给工厂类去完成，（场景工厂是进行产品加工生产的地方，所以对象的产生也要交给工厂类）

1.简单工厂模式：一个抽象产品类，多个具体产品类，一个具体工厂类，通过输入来确定制造那个产品（实例化那个对象）

2.工厂方法模式：一个抽象产品类，多个具体产品类，一个抽象工厂类，多个具体工厂类（改变的原因是正常情况下，两个不同的厂家的产品不能在一个工厂生产  同理两个类的实例化也不应该在同一个工厂类中）

3.抽象方法模式:多个抽象产品类，多个具体产品类，多个抽象方法类，多个具体工厂类



代理模式，（一个接口，两个类一个真实业务类，一个辅助业务类）

1.在辅助业务类中传入真实业务对象，核心步骤由真是业务类完成（代购 等等）



单例模式：类只能实例化一个对象，用于特定的场景，宇宙只有一个太阳等等

用私有狗仔方法，将实例化放到类的里面，用static方法取 出



final String 

 String类是一种引用数据类型

1.字符串常量是String类的匿名对象，"字符串常量".equal方法

2.对象实例化有两种方式，第一种 直接赋值，产生一块堆内存，第二种  构造法（一般法）产生两块空间，齐总一块变成垃圾空间；

2.equals方法与==（区别）

equals:比较的是字符串的内容；

==：比较的是两块空间的内存（对象引用）

3.直接赋值与构造法的区别：

1.直接赋值，java采取的是共享机制，直接赋值时会在字符串常量池里查找，如果已经有该对象就使用已有对象，如果没有就将其保存到字符串常量池中 方便下次使用；

所以用== 比较返回为true;

String类的方法：

字符串与字符数组的相互转换，

​	字符数组转字符串 构造方法String（字符数组，【起始位置，长度】）

​	根据索引，找到取出指定字符 charAt()

​	字符串全部变成字符数组    toCharArray()



字符串和byte数组互相转换：

​	String（byte数组，【起始位置，起始长度】）

​	getBytes()



字符串比较：

​		1.区分大小写的比较

​			equals(String)

​		2.不区分大小写的比较

​			equalsIqnoreCase(String)

​		3.比较大小

​			compare(String str)

字符串查找：

​		1.是否存在该子串  contains

​		2.从起始位置查询该子串的位置  indexOf(String str)

​		3.从指定位置开始该子串的位置 indexOf(String str ,起始位置)

​		4.从字符串结尾开始 寻找子串位置 lastIndexOf(String str)

​		5.从字符串结尾开始的指定位置 寻找子串位置 lastIndexOf(String str,指定位置）

​		7.字符串是否以指定字符串开始 startWith(String str)

​		8.指定位置字符串是否以指定字符串开始startWith(String str ,int index);

​		9.字符串是否以指定字符串结尾 endWith(String str)

字符串替换

​		1、字符串全替换：replaceAll(String str)

​		2、字符串首字符串替换： replaceFirst(String str)

字符串拆分：

​		1、split(以那个字符串拆)

​		2、spilt(以哪个字符串拆分，几个)

字符串截取：

​		1.substring(从指定索引截取到结尾)

​		2.substring(截取部分内容【开始，结尾】)

trim() 去除开头结尾空格

toUpperCase()字符串转大写

toLowerCase()字符串转小写

intern()字符串入池

length()

concat()

isEmpty()

 sb类

改变字符串内容, 特有方法 delete()  ,resverse(),insert();

String 与SB类的区别：1.字符串内容不可更改，而SB类的内容可以更改， 但是实际上，在进行+操作时JVM会自动将String转换成StringBulider然后进行Append操作

Sbuffer,属于同步操作，线程安全操作，效率低；Sbulider,异步操作，线程不安全操作，效率高

Object:

所有类的父类，方法

toString()获取对象信息

equals()比较对象

final Integer

包装类，手动拆装箱，自动拆装箱；

Interger 类型 范围在-128~127之间 ==相等    出了这个范围 用equals

 普通类型转换String 

String转换普通类型

valueOf

parseInt



