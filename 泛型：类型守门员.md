泛型：类型守门员

解决对象向下转型时的java.lang.ClassCastException的问题

1.<>修饰符

 泛型类  在类定义时有<T>  

```java
class Person<T>{}
```



在类定义的时候不会定义类里面属性或者方法，在类使用的时候在进行定义，<>里面的T叫做类型参数，可以有多个类型参数

用泛型类实例化对象，的方法  

```java
Person<String> per=new Person<>(); //前面的尖括号里面的必须是类，不能是基本类型
```

泛型方法  在方法上有尖括号  只有类型参数不是泛型方法

```java
public <T> T print(T t)
```

 

通配符：为了解决参数统一化的问题，因为以前只需要用Object接收就行

1.只能有一个通配符

1.<?>用在方法级别上，可以接收任何参数

2.<? extends T> 用在类和方法上 并且接收的参数必须是T 及其子类

3.<? super T>用在方法级别上  并且接收的参数必须是T及其父类；



这三种方法里面只有3.可以用接收到的对象来修改属性值，因为发生天然的向上转型



泛型接口：

子类实现泛型接口时 有两种方式，1.子类也是泛型类 ，2.子类不做泛型类，在继承时 接口设置好类型

类型擦除，在JVM中所有类型都是基本数据类型如果设置上限则擦除成对应上限，否则则设置成Object



可变参数  ，为了不定数据传入方法中的问题，类型...data

1.如果形参中还有别的参数那么可变参数一定放到最后，只能设置一个可变参数



枚举：

关键字 ：enum

枚举是个实际上是继承了java一个现有的抽象类，Enum类

实际上 enum 枚举名{} 等价于 名字，classExtends Enum

既然枚举是继承自 Enum 那么，它里面也可已有普通属性，构造方法，普通方法，实际上枚举就是多例的简单实现



Enum的方法

1.构造方法：

2.getName() 获得枚举对象的名字

3.ordinal() 目前枚举对象是哪个第几个

4.values获取所有枚举对象



注释Annotation

1.准确覆写

@override

2.过期声明

@Deprected

3.压制警告

@SuppressWarning



Lamda表达式 ：函数式编程（重要函数式编程的接口只允许有一个接口）

实际上就是匿名内部类的简化形式

方法引用：实际上就是引用 方法的实现形式

1.应用类的静态方法：  static ::方法名

2.引用类方法  :     类名::方法名  //

3.引用对象方法： 对象名::方法名  //

4.应用构造方法  类名：：new  //引用构造方法的时候，构造方法实际上就是返回了一个实例化对象，



反射：

反射就是先根据对象获取该对象类的信息，根据对象返回的信息，实例化类



1.JVM中每个类都有一个class对象，来记录每个类的结构(构造方法，普通属性，普通方法)

2.有一个方法可以获取对象信息    public final native class<?> getClass()

Class

描述的就是类



产生类的对象一共有三种方式：

1.getClass() 方法

2.类名.class

3.Class.forName("类的全面成")



2.通过反射实例化对象，newInstance();

